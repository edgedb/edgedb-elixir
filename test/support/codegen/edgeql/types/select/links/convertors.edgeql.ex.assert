# AUTOGENERATED: DO NOT MODIFY
# Generated by Elixir client for EdgeDB via `mix edgedb.generate` from
#   `test/support/codegen/edgeql/types/select/links/convertors.edgeql`.
defmodule Tests.Codegen.Queries.Types.Select.Links.Convertors do
  @query """
  select v4::codegen::Aggregate {
      rl_number: {
          ol_int64: {
              mp_int64,
              mp_int64_type,
          }
      },
      ml_tuple: {
          rl_unnamed_tuple: {
              op_unnamed_tuple,
          },
          ol_named_tuple: {
              rp_named_tuple,
          }
      }
  }
  """

  @moduledoc """
  Generated module for the EdgeQL query from
    `test/support/codegen/edgeql/types/select/links/convertors.edgeql`.

  Query:

  ```edgeql
  #{@query}
  ```
  """

  @query_file "test/support/codegen/edgeql/types/select/links/convertors.edgeql"

  @typedoc """
  ```edgeql
  scalar type v4::codegen::Int64Type extending std::int64
  ```
  """
  @type v4__codegen__int64_type() :: integer()

  @typedoc """
  ```edgeql
  scalar type v4::codegen::EnumType extending enum<A, B, C>
  ```
  """
  @type v4__codegen__enum_type() :: :A | :B | :C

  defmodule Result do
    @moduledoc false

    defmodule RlNumber do
      @moduledoc false

      defmodule OlInt64 do
        @moduledoc false

        defstruct [
          :mp_int64,
          :mp_int64_type
        ]

        @type t() :: %__MODULE__{
                mp_int64: [integer()],
                mp_int64_type: [
                  Tests.Codegen.Queries.Types.Select.Links.Convertors.v4__codegen__int64_type()
                ]
              }
      end

      defstruct [
        :ol_int64
      ]

      @type t() :: %__MODULE__{
              ol_int64: OlInt64.t() | nil
            }
    end

    defmodule MlTuple do
      @moduledoc false

      defmodule RlUnnamedTuple do
        @moduledoc false

        defstruct [
          :op_unnamed_tuple
        ]

        @type t() :: %__MODULE__{
                op_unnamed_tuple:
                  {String.t(), boolean(),
                   {String.t(), boolean(),
                    Tests.Codegen.Queries.Types.Select.Links.Convertors.v4__codegen__enum_type()}}
                  | nil
              }
      end

      defmodule OlNamedTuple do
        @moduledoc false

        defstruct [
          :rp_named_tuple
        ]

        @type t() :: %__MODULE__{
                rp_named_tuple: %{
                  a: String.t(),
                  b: boolean(),
                  c: %{
                    a: String.t(),
                    b: boolean(),
                    c:
                      Tests.Codegen.Queries.Types.Select.Links.Convertors.v4__codegen__enum_type()
                  }
                }
              }
      end

      defstruct [
        :rl_unnamed_tuple,
        :ol_named_tuple
      ]

      @type t() :: %__MODULE__{
              rl_unnamed_tuple: RlUnnamedTuple.t(),
              ol_named_tuple: OlNamedTuple.t() | nil
            }
    end

    defstruct [
      :rl_number,
      :ml_tuple
    ]

    @type t() :: %__MODULE__{
            rl_number: RlNumber.t(),
            ml_tuple: [MlTuple.t()]
          }
  end

  @doc """
  Run the query.
  """
  @spec query(
          client :: EdgeDB.client(),
          opts :: list(EdgeDB.query_option())
        ) :: {:ok, [Result.t()]} | {:error, reason}
        when reason: any()
  def query(client, opts \\ []) do
    do_query(client, [], opts)
  end

  @doc """
  Run the query.
  """
  @spec query!(
          client :: EdgeDB.client(),
          opts :: list(EdgeDB.query_option())
        ) :: [Result.t()]
  def query!(client, opts \\ []) do
    case do_query(client, [], opts) do
      {:ok, result} ->
        result

      {:error, exc} ->
        raise exc
    end
  end

  defp do_query(client, args, opts) do
    opts = Keyword.merge(opts, __file__: @query_file)

    with {:ok, set} <- EdgeDB.query(client, @query, args, opts) do
      result =
        for element <- set do
          %Result{
            rl_number:
              with link <- element["rl_number"] do
                %Result.RlNumber{
                  ol_int64:
                    with link when not is_nil(link) <- link["ol_int64"] do
                      %Result.RlNumber.OlInt64{
                        mp_int64: link["mp_int64"],
                        mp_int64_type: link["mp_int64_type"]
                      }
                    end
                }
              end,
            ml_tuple:
              with link <- element["ml_tuple"] do
                for element <- link do
                  %Result.MlTuple{
                    rl_unnamed_tuple:
                      with link <- element["rl_unnamed_tuple"] do
                        %Result.MlTuple.RlUnnamedTuple{
                          op_unnamed_tuple:
                            with property when not is_nil(property) <- link["op_unnamed_tuple"] do
                              with {
                                     element_0,
                                     element_1,
                                     element_2
                                   } <- property do
                                {
                                  element_0,
                                  element_1,
                                  with element <- element_2 do
                                    with {
                                           element_0,
                                           element_1,
                                           element_2
                                         } <- element do
                                      {
                                        element_0,
                                        element_1,
                                        with element <- element_2 do
                                          case element do
                                            "A" -> :A
                                            "B" -> :B
                                            "C" -> :C
                                          end
                                        end
                                      }
                                    end
                                  end
                                }
                              end
                            end
                        }
                      end,
                    ol_named_tuple:
                      with link when not is_nil(link) <- element["ol_named_tuple"] do
                        %Result.MlTuple.OlNamedTuple{
                          rp_named_tuple:
                            with property <- link["rp_named_tuple"] do
                              %{
                                a: property["a"],
                                b: property["b"],
                                c:
                                  with element <- property["c"] do
                                    %{
                                      a: element["a"],
                                      b: element["b"],
                                      c:
                                        with element <- element["c"] do
                                          case element do
                                            "A" -> :A
                                            "B" -> :B
                                            "C" -> :C
                                          end
                                        end
                                    }
                                  end
                              }
                            end
                        }
                      end
                  }
                end
              end
          }
        end

      {:ok, result}
    end
  end
end
